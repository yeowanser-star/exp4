# 排序算法在非极大值抑制(NMS)中的应用实验报告

## 一、实验目的

1. 对比四种经典排序算法（快速排序、归并排序、堆排序、插入排序）在不同数据分布（随机分布、聚集分布）下的性能表现
2. 研究非极大值抑制（NMS）算法在目标检测任务中的性能特性
3. 分析数据规模和分布对算法效率的影响规律
4. 验证各排序算法的正确性，展示NMS算法的实际应用效果

## 二、实验环境及工具

- 编程语言：C++
- 开发环境：win11
- 编译器：g++ (C++11标准)

## 三、算法实现

### 1. 系统架构

实验系统采用面向对象设计，包含以下核心组件：

1. BoundingBox类：表示目标检测中的边界框，包含中心坐标、宽高和置信度
2. SortAlgorithm基类及派生类：实现四种排序算法的统一接口
3. DataGenerator类：生成两种不同分布的测试数据（随机分布和聚集分布）
4. NMS类：实现非极大值抑制算法，用于处理重叠边界框
5. PerformanceTester类：负责性能测试和结果分析

```cpp
// 边界框数据结构
class BoundingBox {
    float x, y;         // 中心点坐标
    float w, h;         // 宽度和高度
    float confidence;   // 置信度
    
    // 关键方法：计算交并比(IoU)、获取坐标、计算面积
    float area() const;
    void getCoords(float& x1, float& y1, float& x2, float& y2) const;
};
```

### 2. 排序算法实现

#### 2.1 快速排序（Quick Sort）
- 平均时间复杂度：$O(n log n)$
- 最坏时间复杂度：$O(n²)$
- 在大数据集上表现良好

#### 2.2 插入排序（Insertion Sort）
- 时间复杂度：$O(n²)$
- 在小数据集上有一定的优势

#### 2.3 选择排序（Selection Sort）
- 时间复杂度：$O(n²)$
- 实现简单，但在大数据集上效率较低

#### 2.4 冒泡排序（Bubble Sort）
- 时间复杂度：$O(n²)$
- 效率最低的排序算法，仅用于对比测试

### 3. NMS算法实现
```cpp
static vector<BoundingBox> applyNMS(const vector<BoundingBox>& boxes, float iouThreshold = 0.5f) {
    // 1. 按置信度降序排序
    // 2. 遍历所有边界框，计算IoU
    // 3. 移除重叠度高的边界框
}
```

非极大值抑制算法的主要流程：
1. 按置信度分数对所有边界框进行降序排序
2. 选取置信度最高的框加入输出列表
3. 抑制与该框IoU超过阈值的其他框
4. 重复步骤2-3直到处理完所有框

## 四、实验设计

### 4.1 数据生成策略

#### 4.1.1 随机分布数据
- 边界框在指定区域内随机分布
- 用于模拟一般情况下的目标检测结果

#### 4.1.2 聚集分布数据
- 边界框集中在特定几个区域
- 用于模拟密集场景下的目标检测结果

### 4.2 测试参数设置

- NMS阈值：0.5
- 数据规模：100, 500, 1000
- 重复测试次数：3次取平均值
- 数据分布：随机分布和聚集分布

## 五、实验结果

### 5.1 性能测试数据

#### 随机分布数据测试结果
| 算法 \ 数据量 | 100 | 500 | 1000 |
|---------------|-----|-----|------|
| InsertionSort| 0.000012s | 0.000266s | 0.001073s |
| HeapSort   | 0.000011s | 0.000077s | 0.000175s | 
| MergeSort  | 0.000023s | 0.000121s | 0.000253s |
| QuickSort  | 0.000006s | 0.000040s | 0.000086s |

#### 聚集分布数据测试结果
| 算法 \ 数据量 | 100 | 500 | 1000 |
|---------------|-----|-----|------|
| InsertionSort| 0.000012s | 0.000291s | 0.001163s |
| HeapSort   | 0.000011s | 0.000077s | 0.000212s | 
| MergeSort  | 0.000023s | 0.000123s | 0.000254s |
| QuickSort  | 0.000006s | 0.000038s | 0.000085s |

### 5.2 性能分析

#### 5.2.1 不同排序算法在NMS中的性能对比
- **快速排序**：在大多数情况下表现最佳，特别是在大数据集上优势明显
- **插入排序**：在小数据集上表现不错，在大数据集上略逊于快速排序
- **选择排序**：性能较差，不适用于大数据集
- **冒泡排序**：效率最低，在大数据集上性能急剧下降

性能特点：

- 显著慢于纯排序算法（1000个边界框时，NMS比最快排序慢224倍）
- 数据量从100增至1000（10倍），运行时间增长：
    - 随机分布：72.9倍（接近n²增长）
    - 聚集分布：48.1倍（聚集可能减少有效计算）

#### 5.3 NMS算法示例输出
```text
生成 20 个边界框
前5个边界框:
  1. BBox(x=902.84, y=204.31, w=15.51, h=20.83, conf=0.13)
  2. BBox(x=745.51, y=199.03, w=46.17, h=10.37, conf=0.08)
  3. BBox(x=910.14, y=245.46, w=41.49, h=25.38, conf=0.58)
  4. BBox(x=811.03, y=50.00, w=64.53, h=10.64, conf=0.77)
  5. BBox(x=767.21, y=227.66, w=78.07, h=34.35, conf=0.61)

应用NMS (IoU阈值=0.5) 后，选择 20 个边界框
选择的边界框:
  1. BBox(x=746.79, y=50.00, w=83.54, h=73.49, conf=0.99)
  2. BBox(x=515.76, y=428.56, w=64.35, h=90.32, conf=0.96)
  3. BBox(x=461.21, y=226.66, w=36.95, h=61.77, conf=0.85)
  4. BBox(x=950.00, y=669.42, w=30.53, h=66.14, conf=0.84)
  5. BBox(x=922.33, y=465.46, w=21.46, h=80.41, conf=0.81)
```

## 六、理论分析

### 6.1 NMS算法时间复杂度分析
NMS算法的整体时间复杂度由两部分组成：
- **排序阶段**：O(n log n)（快速排序）或O(n²)（冒泡排序等）
- **抑制阶段**：O(n²) - 需要计算任意两框间的IoU

总体复杂度为O(n²)，由抑制阶段主导，这也是为什么在大数据集上NMS非常耗时的原因。

### 6.2 实际性能与理论的对比
实验结果基本符合理论分析：
- 算法的相对性能排名符合预期
- 数据规模增长对性能的影响呈二次方增长趋势
- 排序算法虽然影响总体性能，但不是主要瓶颈

## 七、总结与展望
本次实验成功构建了一个完整的排序算法与NMS算法性能测试框架，取得了以下主要成果：实现了四种经典排序算法（快速排序、归并排序、堆排序、插入排序）以及非极大值抑制（NMS）算法，所有算法均通过正确性验证。

性能对比分析：

- 快速排序表现最佳：在1000个边界框的测试中，快速排序耗时仅0.000086秒，是四类排序算法中最快的
- 插入排序扩展性差：数据量从100增至1000时，运行时间增长89.4倍，明显呈现O(n²)复杂度特性
- 堆排序与归并排序表现稳定：均展现了O(n log n)的优良扩展性
- NMS成为性能瓶颈：在1000个边界框时耗时0.019322秒，比快速排序慢224倍